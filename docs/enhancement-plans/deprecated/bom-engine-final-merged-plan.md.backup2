# POSMID 2.0 - BOM Engine: FINAL MERGED PLAN
## Best of Both Worlds - Phased Implementation Strategy

**Document Version:** 1.0  
**Last Updated:** 2025-01-XX  
**Status:** âœ… APPROVED FOR IMPLEMENTATION  
**Implementation Strategy:** Phased rollout (MVP â†’ Advanced â†’ Enterprise)

---

## ğŸ“‹ EXECUTIVE SUMMARY

This document represents the **optimal merged plan** combining:
- **Original Plan's strengths:** Simplicity, clarity, actionability
- **Zencoder AI Plan's strengths:** Completeness, future-proofing, specification quality

### Strategic Approach: **3-Phase Rollout**

```
Phase 1 (MVP): Simple & Fast â†’ Market Validation
Phase 2 (Advanced): Enterprise Features â†’ Multi-Industry
Phase 3 (Enterprise): Full ERP-Grade â†’ Competitive Moat
```

### Success Criteria

| Phase | Timeline | Goal | Success Metric |
|-------|----------|------|----------------|
| **Phase 1 (MVP)** | 4-6 weeks | Prove concept works | 3-5 pilot customers, >8/10 satisfaction |
| **Phase 2 (Advanced)** | 6-8 weeks | Multi-industry support | 20+ leads, 2.5x pricing achieved |
| **Phase 3 (Enterprise)** | 8-12 weeks | Market leadership | 100+ customers, <5% churn |

---

## ğŸ¯ PHASE 1: MVP (WEEKS 1-6)

**Philosophy:** **"Ship fast, validate early"**

### Goals
1. âœ… Prove core BOM concept works
2. âœ… Get real user feedback ASAP
3. âœ… Generate initial revenue from pilot customers
4. âœ… Avoid over-engineering

---

### 1.1 Database Schema (Phase 1)

#### Table: `ingredients`
**Purpose:** Simple raw material tracking

```sql
CREATE TABLE ingredients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    
    -- Basic Info
    name VARCHAR(255) NOT NULL,
    sku VARCHAR(100),
    description TEXT,
    
    -- Measurement
    unit_of_measurement VARCHAR(50) NOT NULL,  -- gram, ml, pcs, kg, liter
    
    -- Stock
    current_stock DECIMAL(15, 4) DEFAULT 0,
    
    -- Reordering
    reorder_point DECIMAL(15, 4),
    
    -- Costing (Simple)
    cost_per_unit DECIMAL(15, 4),
    
    -- Metadata
    is_active BOOLEAN DEFAULT TRUE,
    notes TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    UNIQUE (tenant_id, sku)
);

CREATE INDEX idx_ingredients_tenant ON ingredients(tenant_id, is_active);
CREATE INDEX idx_ingredients_low_stock ON ingredients(tenant_id) 
    WHERE is_active = TRUE AND current_stock <= reorder_point;
```

---

#### Table: `recipes`
**Purpose:** Define product composition

```sql
CREATE TABLE recipes (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    
    -- Link to Product
    product_id UUID NOT NULL,
    variant_id UUID,  -- Support for variant-level recipes (from Zencoder plan)
    
    -- Recipe Info
    name VARCHAR(255) NOT NULL,
    description TEXT,
    
    -- Production
    yield_quantity DECIMAL(10, 2) DEFAULT 1.00,  -- How many units this produces
    
    -- Costing (Auto-calculated)
    total_material_cost DECIMAL(15, 4),
    
    -- Metadata
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(id) ON DELETE CASCADE,
    FOREIGN KEY (variant_id) REFERENCES product_variants(id) ON DELETE CASCADE,
    
    UNIQUE (tenant_id, product_id, variant_id) WHERE is_active = TRUE
);

CREATE INDEX idx_recipes_product ON recipes(product_id, is_active);
CREATE INDEX idx_recipes_variant ON recipes(variant_id) WHERE variant_id IS NOT NULL;
```

---

#### Table: `recipe_ingredients`
**Purpose:** Components per recipe

```sql
CREATE TABLE recipe_ingredients (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    recipe_id UUID NOT NULL,
    ingredient_id UUID NOT NULL,
    
    -- Quantity
    quantity_required DECIMAL(15, 6) NOT NULL,
    
    -- Waste Factor (from Zencoder plan - important for accuracy!)
    waste_percentage DECIMAL(5, 2) DEFAULT 0,  -- e.g., 5.00 = 5%
    actual_quantity DECIMAL(15, 6) GENERATED ALWAYS AS 
        (quantity_required * (1 + waste_percentage/100)) STORED,
    
    -- Cost Snapshot (for historical accuracy)
    unit_cost_snapshot DECIMAL(15, 4),
    
    -- Display
    sort_order INTEGER DEFAULT 0,
    notes TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (recipe_id) REFERENCES recipes(id) ON DELETE CASCADE,
    FOREIGN KEY (ingredient_id) REFERENCES ingredients(id) ON DELETE RESTRICT,
    
    UNIQUE (recipe_id, ingredient_id)
);

CREATE INDEX idx_recipe_ingredients_recipe ON recipe_ingredients(recipe_id);
CREATE INDEX idx_recipe_ingredients_ingredient ON recipe_ingredients(ingredient_id);
```

---

#### Table: `ingredient_transactions`
**Purpose:** Complete audit trail

```sql
CREATE TABLE ingredient_transactions (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    ingredient_id UUID NOT NULL,
    
    -- Transaction Type
    transaction_type ENUM(
        'purchase',         -- Purchased from supplier
        'sale_deduction',   -- Used in sale (via recipe)
        'adjustment',       -- Manual adjustment
        'waste',            -- Wastage
        'return'            -- Return/refund
    ) NOT NULL,
    
    -- Quantity
    quantity DECIMAL(15, 6) NOT NULL,  -- Positive = in, Negative = out
    
    -- Stock Snapshot
    stock_before DECIMAL(15, 6) NOT NULL,
    stock_after DECIMAL(15, 6) NOT NULL,
    
    -- Costing
    unit_cost DECIMAL(15, 4),
    total_value DECIMAL(15, 4) GENERATED ALWAYS AS 
        (ABS(quantity) * COALESCE(unit_cost, 0)) STORED,
    
    -- References
    reference_type VARCHAR(50),  -- Order, Adjustment, etc.
    reference_id UUID,
    
    -- Actor & Reason
    user_id UUID,
    reason TEXT,
    notes TEXT,
    
    -- Timestamp
    transaction_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    FOREIGN KEY (ingredient_id) REFERENCES ingredients(id) ON DELETE RESTRICT,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX idx_ingredient_transactions_ingredient ON ingredient_transactions(ingredient_id, transaction_date DESC);
CREATE INDEX idx_ingredient_transactions_type ON ingredient_transactions(tenant_id, transaction_type, transaction_date DESC);
CREATE INDEX idx_ingredient_transactions_reference ON ingredient_transactions(reference_type, reference_id);
```

---

#### Product Table Modifications

```sql
-- Add to existing products table
ALTER TABLE products ADD COLUMN inventory_management_type ENUM(
    'none',      -- No inventory (services)
    'simple',    -- Direct stock (current behavior)
    'composite'  -- Recipe-based (new!)
) DEFAULT 'simple';

ALTER TABLE products ADD COLUMN active_recipe_id UUID;
ALTER TABLE products ADD CONSTRAINT fk_products_active_recipe 
    FOREIGN KEY (active_recipe_id) REFERENCES recipes(id) ON DELETE SET NULL;

-- Add to product_variants table
ALTER TABLE product_variants ADD COLUMN has_custom_recipe BOOLEAN DEFAULT FALSE;
ALTER TABLE product_variants ADD COLUMN active_recipe_id UUID;
ALTER TABLE product_variants ADD CONSTRAINT fk_variants_active_recipe 
    FOREIGN KEY (active_recipe_id) REFERENCES recipes(id) ON DELETE SET NULL;

-- Add index
CREATE INDEX idx_products_inventory_type ON products(tenant_id, inventory_management_type);
```

**Design Decision Notes:**
- âœ… Uses `inventory_management_type` (Zencoder) instead of `type` (clearer semantics)
- âœ… Supports variant-level recipes (Zencoder enhancement)
- âœ… Keeps schema simple (Original plan's philosophy)

---

### 1.2 Backend Services (Phase 1)

#### Service: `IngredientService`

**Location:** `src/Pms/Core/Application/Services/Inventory/IngredientService.php`

**Methods:**
```php
class IngredientService
{
    // CRUD
    public function create(CreateIngredientDTO $dto): Ingredient;
    public function update(Ingredient $ingredient, UpdateIngredientDTO $dto): Ingredient;
    public function delete(Ingredient $ingredient): void;
    
    // Stock Management
    public function adjustStock(
        Ingredient $ingredient,
        string $adjustmentType,  // 'add', 'subtract', 'set'
        float $quantity,
        string $reason,
        ?string $referenceNumber = null
    ): IngredientTransaction;
    
    // Helper
    public function isLowStock(Ingredient $ingredient): bool;
}
```

---

#### Service: `RecipeService`

**Location:** `src/Pms/Core/Application/Services/Inventory/RecipeService.php`

**Methods:**
```php
class RecipeService
{
    // CRUD
    public function create(CreateRecipeDTO $dto): Recipe;
    public function update(Recipe $recipe, UpdateRecipeDTO $dto): Recipe;
    public function delete(Recipe $recipe): void;
    
    // Components
    public function addComponent(Recipe $recipe, AddComponentDTO $dto): RecipeIngredient;
    public function updateComponent(RecipeIngredient $component, UpdateComponentDTO $dto): RecipeIngredient;
    public function removeComponent(RecipeIngredient $component): void;
    
    // Costing
    public function calculateTotalCost(Recipe $recipe): float;
    public function updateCostSnapshots(Recipe $recipe): void;
}
```

---

#### Service: `InventoryCalculationService`

**Location:** `src/Pms/Core/Application/Services/Inventory/InventoryCalculationService.php`

**Methods:**
```php
class InventoryCalculationService
{
    /**
     * Calculate maximum producible quantity
     * 
     * @return array{
     *   type: string,
     *   maximum_producible_quantity?: int,
     *   limiting_ingredient?: array,
     *   all_ingredients_availability?: array
     * }
     */
    public function calculateAvailableQuantity(
        Product $product,
        ?ProductVariant $variant = null
    ): array {
        // For simple products
        if ($product->inventory_management_type === 'simple') {
            return [
                'type' => 'simple',
                'current_stock' => $variant 
                    ? $variant->stock_quantity 
                    : $product->stock_quantity
            ];
        }
        
        // For composite products
        $recipe = $this->getActiveRecipe($product, $variant);
        
        if (!$recipe) {
            throw new NoRecipeFoundException();
        }
        
        $components = $recipe->ingredients()->with('ingredient')->get();
        
        $maxProducible = PHP_INT_MAX;
        $limitingIngredient = null;
        $ingredientDetails = [];
        
        foreach ($components as $component) {
            $ingredient = $component->ingredient;
            $requiredQty = $component->actual_quantity;  // Includes waste factor
            
            // Calculate max units from this ingredient
            $maxFromThis = floor($ingredient->current_stock / $requiredQty);
            
            $ingredientDetails[] = [
                'ingredient_id' => $ingredient->id,
                'ingredient_name' => $ingredient->name,
                'required_quantity' => $requiredQty,
                'available_stock' => $ingredient->current_stock,
                'sufficient' => $ingredient->current_stock >= $requiredQty,
                'max_producible' => $maxFromThis
            ];
            
            // Track bottleneck
            if ($maxFromThis < $maxProducible) {
                $maxProducible = $maxFromThis;
                $limitingIngredient = [
                    'ingredient_id' => $ingredient->id,
                    'ingredient_name' => $ingredient->name,
                    'required_per_unit' => $requiredQty,
                    'available_stock' => $ingredient->current_stock,
                    'max_units' => $maxFromThis
                ];
            }
        }
        
        return [
            'type' => 'composite',
            'maximum_producible_quantity' => max(0, $maxProducible),
            'limiting_ingredient' => $limitingIngredient,
            'all_ingredients_availability' => $ingredientDetails
        ];
    }
    
    /**
     * Check if sufficient ingredients exist
     */
    public function checkSufficiency(Recipe $recipe, int $quantity): array
    {
        $components = $recipe->ingredients()->with('ingredient')->get();
        $missing = [];
        
        foreach ($components as $component) {
            $required = $component->actual_quantity * $quantity;
            $available = $component->ingredient->current_stock;
            
            if ($available < $required) {
                $missing[] = [
                    'ingredient' => $component->ingredient->name,
                    'required' => $required,
                    'available' => $available,
                    'shortage' => $required - $available
                ];
            }
        }
        
        return [
            'sufficient' => empty($missing),
            'missing_ingredients' => $missing
        ];
    }
}
```

---

#### Service: `InventoryDeductionService`

**Location:** `src/Pms/Core/Application/Services/Inventory/InventoryDeductionService.php`

**Methods:**
```php
class InventoryDeductionService
{
    /**
     * Process inventory deduction for an order
     */
    public function processOrderDeduction(Order $order): void
    {
        DB::transaction(function () use ($order) {
            foreach ($order->items as $orderItem) {
                $product = $orderItem->product;
                $variant = $orderItem->variant;
                
                if ($product->inventory_management_type === 'simple') {
                    // Existing logic: deduct product stock
                    $this->deductSimpleStock($product, $variant, $orderItem->quantity);
                } 
                elseif ($product->inventory_management_type === 'composite') {
                    // New logic: deduct recipe ingredients
                    $this->deductRecipeIngredients(
                        $product,
                        $variant,
                        $orderItem->quantity,
                        $order
                    );
                }
            }
        });
    }
    
    /**
     * Deduct ingredients for composite product
     */
    private function deductRecipeIngredients(
        Product $product,
        ?ProductVariant $variant,
        int $quantity,
        Order $order
    ): void {
        $recipe = $variant?->activeRecipe ?? $product->activeRecipe;
        
        if (!$recipe) {
            throw new NoRecipeFoundException();
        }
        
        // Check sufficiency first
        $check = $this->calculationService->checkSufficiency($recipe, $quantity);
        if (!$check['sufficient']) {
            throw new InsufficientStockException($check['missing_ingredients']);
        }
        
        // Deduct each ingredient
        foreach ($recipe->ingredients as $component) {
            $ingredient = $component->ingredient;
            $totalRequired = $component->actual_quantity * $quantity;
            
            $oldStock = $ingredient->current_stock;
            $ingredient->current_stock -= $totalRequired;
            $ingredient->save();
            
            // Log transaction
            IngredientTransaction::create([
                'tenant_id' => $order->tenant_id,
                'ingredient_id' => $ingredient->id,
                'transaction_type' => 'sale_deduction',
                'quantity' => -$totalRequired,
                'stock_before' => $oldStock,
                'stock_after' => $ingredient->current_stock,
                'unit_cost' => $ingredient->cost_per_unit,
                'reference_type' => 'Order',
                'reference_id' => $order->id,
                'user_id' => auth()->id(),
                'reason' => "Sale: {$product->name} x{$quantity}",
            ]);
        }
    }
}
```

---

### 1.3 API Endpoints (Phase 1)

**Reference:** Use full OpenAPI spec from `bom-openapi-specification.yaml`

**Priority Endpoints for Phase 1:**

#### Ingredients
- âœ… `GET /tenants/{tenantId}/inventory/ingredients` - List
- âœ… `POST /tenants/{tenantId}/inventory/ingredients` - Create
- âœ… `GET /tenants/{tenantId}/inventory/ingredients/{id}` - Get one
- âœ… `PATCH /tenants/{tenantId}/inventory/ingredients/{id}` - Update
- âœ… `POST /tenants/{tenantId}/inventory/ingredients/{id}/adjust` - Adjust stock

#### Recipes
- âœ… `GET /tenants/{tenantId}/inventory/recipes` - List
- âœ… `POST /tenants/{tenantId}/inventory/recipes` - Create
- âœ… `GET /tenants/{tenantId}/inventory/recipes/{id}` - Get one
- âœ… `PUT /tenants/{tenantId}/inventory/recipes/{id}` - Update
- âœ… `DELETE /tenants/{tenantId}/inventory/recipes/{id}` - Delete

#### Products Integration
- âœ… `GET /tenants/{tenantId}/products/{id}/available-quantity` - Calculate stock
- âœ… Modify `POST /tenants/{tenantId}/orders` to trigger deduction

#### Transactions
- âœ… `GET /tenants/{tenantId}/inventory/transactions` - History

**Defer to Phase 2:**
- â³ Batches endpoints
- â³ Suppliers endpoints
- â³ Waste logs endpoints
- â³ Analytics endpoints (except one: Recipe Costing Simulator)

---

### 1.4 Frontend (Phase 1)

**Priority Features:**

#### 1. Ingredient Management Page
- âœ… List ingredients (table with pagination)
- âœ… Add/Edit ingredient (form)
- âœ… Adjust stock (modal)
- âœ… Low stock indicator (badge)

#### 2. Recipe Builder
- âœ… Recipe form (product selector, name, description)
- âœ… Component adder (ingredient selector + quantity + waste%)
- âœ… Cost calculator (auto-calculate total material cost)
- âœ… Save/Update recipe

#### 3. POS Integration
- âœ… Real-time stock display
  - Simple products: Show `stock_quantity`
  - Composite products: Call `/available-quantity` API, show `maximum_producible_quantity`
- âœ… Out-of-stock overlay (grey out if quantity = 0)

#### 4. ONE WOW Feature: Recipe Costing Simulator
- âœ… Simple page: List ingredients with editable costs
- âœ… When cost changes â†’ recalculate all affected products
- âœ… Show old margin vs new margin
- âœ… Suggest new price to maintain margin
- âœ… **Frontend-only** (no backend needed)

**Defer to Phase 2:**
- â³ Batch management UI
- â³ Expiry alerts dashboard
- â³ Menu engineering matrix
- â³ Waste logging UI
- â³ Purchase order management

---

### 1.5 Testing (Phase 1)

**Unit Tests:**
- âœ… `IngredientService` methods
- âœ… `RecipeService` methods
- âœ… `InventoryCalculationService::calculateAvailableQuantity()`
- âœ… `InventoryDeductionService::deductRecipeIngredients()`

**Feature Tests:**
- âœ… Create ingredient via API
- âœ… Create recipe with components
- âœ… Calculate available quantity (simple product)
- âœ… Calculate available quantity (composite product)
- âœ… Create order â†’ verify ingredient deduction
- âœ… Transaction log created correctly

**Integration Tests:**
- âœ… End-to-end flow:
  1. Create ingredients (Coffee, Sugar)
  2. Create product ("Iced Coffee")
  3. Create recipe (15g coffee + 10g sugar)
  4. Create order (2x Iced Coffee)
  5. Verify: Coffee reduced by 30g, Sugar by 20g
  6. Verify: Transactions logged

**Target Coverage:** >80%

---

### 1.6 Documentation (Phase 1)

**User Docs:**
- âœ… Quick Start: "Create your first recipe in 5 minutes"
- âœ… Video tutorial: Recipe builder walkthrough
- âœ… FAQ: Common questions

**Developer Docs:**
- âœ… API documentation (OpenAPI spec)
- âœ… Database schema diagram
- âœ… Service layer explanation

---

### 1.7 Success Criteria (Phase 1)

| Metric | Target | Measurement |
|--------|--------|-------------|
| **Feature Completeness** | 100% of Phase 1 scope | Checklist review |
| **Test Coverage** | >80% | PHPUnit report |
| **API Response Time** | <200ms (p95) | Load testing |
| **Bug-Free Deployment** | 0 P0/P1 bugs | QA testing |
| **Pilot Customer Sign-up** | 3-5 customers | Sales pipeline |
| **User Satisfaction** | >8/10 | Survey after 2 weeks |

---

## ğŸš€ PHASE 2: ADVANCED FEATURES (WEEKS 7-14)

**Philosophy:** **"Scale to multi-industry, add intelligence"**

### Goals
1. âœ… Support perishable items (FnB industry)
2. âœ… Add batch tracking with FEFO
3. âœ… Enable supplier integration
4. âœ… Implement remaining WOW features
5. âœ… Multi-level BOM support

---

### 2.1 Database Schema Additions (Phase 2)

#### Table: `inventory_batches`
**Purpose:** Track batches for perishable items

```sql
CREATE TABLE inventory_batches (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    ingredient_id UUID NOT NULL,
    
    -- Batch Info
    batch_number VARCHAR(100) NOT NULL,
    received_date DATE NOT NULL,
    expiry_date DATE,
    
    -- Quantity
    initial_quantity DECIMAL(15, 6) NOT NULL,
    current_quantity DECIMAL(15, 6) NOT NULL,
    
    -- Costing
    unit_cost DECIMAL(15, 4) NOT NULL,
    
    -- Supplier
    supplier_id UUID,
    
    -- Status
    status ENUM('active', 'expired', 'depleted', 'quarantined') DEFAULT 'active',
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    FOREIGN KEY (ingredient_id) REFERENCES ingredients(id) ON DELETE CASCADE,
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL,
    
    UNIQUE (tenant_id, ingredient_id, batch_number)
);

CREATE INDEX idx_batches_ingredient ON inventory_batches(ingredient_id, status);
CREATE INDEX idx_batches_expiry ON inventory_batches(tenant_id, expiry_date) 
    WHERE expiry_date IS NOT NULL AND status = 'active';
```

---

#### Table: `suppliers`

```sql
CREATE TABLE suppliers (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    
    name VARCHAR(255) NOT NULL,
    code VARCHAR(50),
    contact_person VARCHAR(255),
    email VARCHAR(255),
    phone VARCHAR(50),
    
    lead_time_days INTEGER DEFAULT 7,
    minimum_order_value DECIMAL(15, 4),
    
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    UNIQUE (tenant_id, code)
);
```

---

#### Table: `waste_logs`

```sql
CREATE TABLE waste_logs (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL,
    ingredient_id UUID NOT NULL,
    
    quantity_wasted DECIMAL(15, 6) NOT NULL,
    reason VARCHAR(100),  -- spoilage, spillage, damaged, expired
    cost_impact DECIMAL(15, 4),
    
    logged_by UUID,
    notes TEXT,
    
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
    FOREIGN KEY (ingredient_id) REFERENCES ingredients(id) ON DELETE RESTRICT,
    FOREIGN KEY (logged_by) REFERENCES users(id) ON DELETE SET NULL
);

CREATE INDEX idx_waste_logs_ingredient ON waste_logs(ingredient_id, created_at DESC);
CREATE INDEX idx_waste_logs_tenant_date ON waste_logs(tenant_id, created_at DESC);
```

---

#### Modify `ingredients` Table

```sql
-- Add columns for Phase 2 features
ALTER TABLE ingredients ADD COLUMN tracking_mode ENUM('standard', 'batch', 'perishable') DEFAULT 'standard';
ALTER TABLE ingredients ADD COLUMN default_shelf_life_days INTEGER;
ALTER TABLE ingredients ADD COLUMN primary_supplier_id UUID;
ALTER TABLE ingredients ADD CONSTRAINT fk_ingredients_supplier 
    FOREIGN KEY (primary_supplier_id) REFERENCES suppliers(id) ON DELETE SET NULL;

-- Add reorder quantity (for predictive PO)
ALTER TABLE ingredients ADD COLUMN reorder_quantity DECIMAL(15, 4);
```

---

### 2.2 New Services (Phase 2)

#### Service: `BatchTrackingService`

```php
class BatchTrackingService
{
    /**
     * Deduct from batches using FEFO (First Expire First Out)
     */
    public function deductFromBatches(
        Ingredient $ingredient,
        float $quantity,
        Order $order
    ): void {
        // Get active batches, ordered by expiry date
        $batches = InventoryBatch::where('ingredient_id', $ingredient->id)
            ->where('status', 'active')
            ->where('current_quantity', '>', 0)
            ->orderBy('expiry_date', 'asc')  // FEFO
            ->get();
        
        $remaining = $quantity;
        
        foreach ($batches as $batch) {
            if ($remaining <= 0) break;
            
            $deductFromBatch = min($remaining, $batch->current_quantity);
            
            // Update batch
            $batch->current_quantity -= $deductFromBatch;
            if ($batch->current_quantity <= 0) {
                $batch->status = 'depleted';
            }
            $batch->save();
            
            // Log transaction
            IngredientTransaction::create([
                'tenant_id' => $ingredient->tenant_id,
                'ingredient_id' => $ingredient->id,
                'batch_id' => $batch->id,
                'transaction_type' => 'sale_deduction',
                'quantity' => -$deductFromBatch,
                'reference_type' => 'Order',
                'reference_id' => $order->id,
                'unit_cost' => $batch->unit_cost,
            ]);
            
            $remaining -= $deductFromBatch;
        }
        
        if ($remaining > 0) {
            throw new InsufficientStockException();
        }
    }
}
```

---

#### Job: `CheckExpiringBatchesJob`

```php
class CheckExpiringBatchesJob implements ShouldQueue
{
    public function handle()
    {
        $warningDays = 7;  // Configurable per tenant
        $warningDate = now()->addDays($warningDays);
        
        $expiringBatches = InventoryBatch::where('status', 'active')
            ->whereNotNull('expiry_date')
            ->where('expiry_date', '<=', $warningDate)
            ->where('expiry_date', '>=', now())
            ->with(['ingredient', 'tenant'])
            ->get();
        
        foreach ($expiringBatches as $batch) {
            $daysLeft = now()->diffInDays($batch->expiry_date);
            
            event(new BatchExpiryWarning($batch, $daysLeft));
        }
    }
}
```

---

#### Job: `ForecastStockJob` (Predictive PO)

```php
class ForecastStockJob implements ShouldQueue
{
    public function handle()
    {
        $tenants = Tenant::active()->get();
        
        foreach ($tenants as $tenant) {
            $ingredients = Ingredient::where('tenant_id', $tenant->id)
                ->where('is_active', true)
                ->whereNotNull('reorder_point')
                ->get();
            
            foreach ($ingredients as $ingredient) {
                $this->checkIngredient($ingredient);
            }
        }
    }
    
    private function checkIngredient(Ingredient $ingredient): void
    {
        // Calculate daily consumption (last 30 days)
        $thirtyDaysAgo = now()->subDays(30);
        $totalUsed = IngredientTransaction::where('ingredient_id', $ingredient->id)
            ->whereIn('transaction_type', ['sale_deduction'])
            ->where('transaction_date', '>=', $thirtyDaysAgo)
            ->sum('quantity');
        
        $dailyConsumption = abs($totalUsed) / 30;
        
        if ($dailyConsumption <= 0) return;
        
        $daysUntilStockout = $ingredient->current_stock / $dailyConsumption;
        $leadTime = $ingredient->primarySupplier?->lead_time_days ?? 7;
        $safetyMargin = 7;
        
        if (($daysUntilStockout - $leadTime) <= $safetyMargin) {
            // Create notification
            Notification::create([
                'tenant_id' => $ingredient->tenant_id,
                'type' => 'low_stock_alert',
                'title' => "Low Stock Alert: {$ingredient->name}",
                'message' => "Will run out in {$daysUntilStockout} days. Daily usage: {$dailyConsumption} {$ingredient->unit_of_measurement}.",
                'data' => [
                    'ingredient_id' => $ingredient->id,
                    'days_until_stockout' => $daysUntilStockout,
                    'recommended_order_quantity' => $ingredient->reorder_quantity,
                ],
            ]);
        }
    }
}
```

---

### 2.3 WOW Features Implementation (Phase 2)

#### Feature: Menu Engineering Matrix

**Endpoint:** `GET /tenants/{tenantId}/analytics/menu-engineering`

```php
class MenuEngineeringController
{
    public function getMatrix(string $tenantId)
    {
        $startDate = request('start_date', now()->subDays(30));
        $endDate = request('end_date', now());
        
        $products = Product::where('tenant_id', $tenantId)
            ->where('inventory_management_type', 'composite')
            ->with(['activeRecipe.ingredients.ingredient'])
            ->get();
        
        $data = [];
        
        foreach ($products as $product) {
            // Get sales data
            $sales = OrderItem::whereHas('order', function ($q) use ($startDate, $endDate) {
                $q->whereBetween('created_at', [$startDate, $endDate]);
            })
            ->where('product_id', $product->id)
            ->sum('quantity');
            
            // Calculate COGS
            $cogs = $product->activeRecipe?->total_material_cost ?? 0;
            
            $revenue = $sales * $product->selling_price;
            $profit = $revenue - ($sales * $cogs);
            $marginPct = $revenue > 0 ? ($profit / $revenue) * 100 : 0;
            
            $data[] = [
                'product_id' => $product->id,
                'product_name' => $product->name,
                'units_sold' => $sales,
                'revenue' => $revenue,
                'cogs' => $cogs,
                'margin_percentage' => round($marginPct, 2),
            ];
        }
        
        // Calculate median
        $medianSales = $this->median(array_column($data, 'units_sold'));
        $medianMargin = $this->median(array_column($data, 'margin_percentage'));
        
        // Assign quadrants
        foreach ($data as &$item) {
            $item['quadrant'] = $this->assignQuadrant(
                $item['units_sold'],
                $item['margin_percentage'],
                $medianSales,
                $medianMargin
            );
        }
        
        return response()->json([
            'data' => $data,
            'thresholds' => [
                'median_sales' => $medianSales,
                'median_margin' => $medianMargin,
            ],
        ]);
    }
    
    private function assignQuadrant($sales, $margin, $medianSales, $medianMargin): string
    {
        if ($sales >= $medianSales && $margin >= $medianMargin) return 'star';
        if ($sales >= $medianSales && $margin < $medianMargin) return 'plow_horse';
        if ($sales < $medianSales && $margin >= $medianMargin) return 'puzzle';
        return 'dog';
    }
}
```

**Frontend:** Scatter plot chart with Recharts

---

#### Feature: Waste Tracking

**Endpoint:** `POST /tenants/{tenantId}/inventory/waste-logs`

```php
class WasteLogController
{
    public function create(string $tenantId, Request $request)
    {
        $request->validate([
            'ingredient_id' => 'required|uuid|exists:ingredients,id',
            'quantity' => 'required|numeric|min:0',
            'reason' => 'required|string|in:spoilage,spillage,damaged,expired,other',
            'notes' => 'nullable|string',
        ]);
        
        DB::transaction(function () use ($request, $tenantId) {
            $ingredient = Ingredient::findOrFail($request->ingredient_id);
            
            // Create log
            $wasteLog = WasteLog::create([
                'tenant_id' => $tenantId,
                'ingredient_id' => $ingredient->id,
                'quantity_wasted' => $request->quantity,
                'reason' => $request->reason,
                'cost_impact' => $request->quantity * $ingredient->cost_per_unit,
                'logged_by' => auth()->id(),
                'notes' => $request->notes,
            ]);
            
            // Deduct stock
            $oldStock = $ingredient->current_stock;
            $ingredient->current_stock -= $request->quantity;
            $ingredient->save();
            
            // Create transaction
            IngredientTransaction::create([
                'tenant_id' => $tenantId,
                'ingredient_id' => $ingredient->id,
                'transaction_type' => 'waste',
                'quantity' => -$request->quantity,
                'stock_before' => $oldStock,
                'stock_after' => $ingredient->current_stock,
                'unit_cost' => $ingredient->cost_per_unit,
                'reference_type' => 'WasteLog',
                'reference_id' => $wasteLog->id,
                'user_id' => auth()->id(),
                'reason' => $request->reason,
            ]);
            
            return response()->json(['success' => true, 'data' => $wasteLog]);
        });
    }
}
```

---

### 2.4 Success Criteria (Phase 2)

| Metric | Target |
|--------|--------|
| **Batch Tracking Accuracy** | 100% (no stock mismatch) |
| **FEFO Deduction** | Oldest batches depleted first |
| **Expiry Warnings** | Sent 7 days before expiry |
| **Predictive PO Accuracy** | >85% (actually runs out of stock when predicted) |
| **Menu Engineering Insights** | >10 actionable recommendations per tenant |
| **Waste Cost Visibility** | Tracked to the penny |
| **New Customer Sign-ups** | 20+ leads generated |
| **Pricing Uplift Achieved** | 2.5x (Rp 200k â†’ Rp 500k) |

---

## ğŸ¢ PHASE 3: ENTERPRISE FEATURES (WEEKS 15-26)

**Philosophy:** **"Become the ERP-grade market leader"**

### Goals
1. âœ… Multi-level BOM (nested recipes)
2. âœ… Multi-warehouse support
3. âœ… Advanced costing (FIFO accounting)
4. âœ… Production planning module
5. âœ… Quality control (quarantine)
6. âœ… Mobile app for inventory

**Defer detailed planning until Phase 2 is validated**

---

## ğŸ“Š OVERALL SUCCESS METRICS

### Technical KPIs

| Metric | Phase 1 | Phase 2 | Phase 3 |
|--------|---------|---------|---------|
| **Test Coverage** | >80% | >85% | >90% |
| **API Response Time (p95)** | <200ms | <150ms | <100ms |
| **Zero Data Loss** | 100% | 100% | 100% |
| **Uptime** | >99% | >99.5% | >99.9% |

### Business KPIs

| Metric | Phase 1 | Phase 2 | Phase 3 |
|--------|---------|---------|---------|
| **Pilot Customers** | 3-5 | 10-20 | 50-100 |
| **Monthly Pricing** | Rp 200k (existing) | Rp 500k | Rp 1M |
| **Feature Satisfaction** | >8/10 | >8.5/10 | >9/10 |
| **Churn Rate** | Baseline | -20% | -30% |
| **Market Positioning** | POS with BOM | Multi-Industry Platform | ERP Alternative |

---

## ğŸ¯ IMMEDIATE NEXT STEPS

### Week 1: Preparation
1. âœ… **Approve this merged plan**
2. âœ… **Set up project tracking** (Jira/Linear)
3. âœ… **Recruit pilot customers** (3-5 friendly businesses)
4. âœ… **Create database migration files** (Phase 1 schema)
5. âœ… **Update OpenAPI spec** in `openapi.yaml`

### Week 2-3: Core Development
1. âœ… **Build models & relationships** (Ingredient, Recipe, RecipeIngredient, IngredientTransaction)
2. âœ… **Build services** (IngredientService, RecipeService, InventoryCalculationService)
3. âœ… **Build API endpoints** (CRUD for ingredients, recipes)
4. âœ… **Write unit tests** (>80% coverage)

### Week 4-5: Frontend Development
1. âœ… **Build ingredient management page**
2. âœ… **Build recipe builder UI**
3. âœ… **Integrate with POS** (real-time stock display)
4. âœ… **Build Recipe Costing Simulator**

### Week 6: Testing & Deployment
1. âœ… **Feature testing** (end-to-end flows)
2. âœ… **QA testing** (bug hunting)
3. âœ… **Deploy to staging**
4. âœ… **Deploy to production** (for pilot customers)
5. âœ… **User training** (video tutorials, documentation)

---

## ğŸ“š APPENDICES

### Appendix A: Comparison with Original Plans

| Feature | Original Plan | Zencoder AI Plan | Merged Plan |
|---------|--------------|------------------|-------------|
| **Schema Simplicity** | âœ… Simple | âŒ Complex | âœ… Simple (Phase 1) â†’ Complex (Phase 2) |
| **Multi-Industry** | âš ï¸ Implied | âœ… Explicit | âœ… Phased approach |
| **Batch Tracking** | âŒ No | âœ… Yes | âœ… Phase 2 |
| **Waste Factor** | âŒ No | âœ… Yes | âœ… Phase 1 |
| **OpenAPI Spec** | âš ï¸ Partial | âœ… Complete | âœ… Complete |
| **Event-Driven** | âŒ No | âœ… Yes | â³ Phase 2 |
| **Time to MVP** | âœ… Fast (4 weeks) | âŒ Slow (8 weeks) | âœ… Fast (6 weeks) |

### Appendix B: Architecture Diagrams

**To be created:**
- Database ERD (Phase 1)
- Service layer diagram
- API flow diagram
- Frontend component hierarchy

### Appendix C: OpenAPI Specification

**Location:** `docs/enhancement-plans/bom-openapi-specification.yaml`

Full specification is available in separate document.

---

## âœ… CONCLUSION

This merged plan combines the **best of both worlds**:

1. **âœ… Simplicity** (Original plan) â†’ Fast MVP, easy to understand
2. **âœ… Completeness** (Zencoder plan) â†’ Future-proof, enterprise-grade
3. **âœ… Phased approach** â†’ Validate early, scale gradually
4. **âœ… Multi-industry** â†’ F&B, Manufacturing, Crafts
5. **âœ… WOW features** â†’ Predictive PO, Menu Engineering, Waste Tracking, Simulator

**Recommended Action:** âœ… **APPROVE and PROCEED with Phase 1**

---

**Document Status:** âœ… READY FOR IMPLEMENTATION  
**Approval Required From:** Product Owner, Tech Lead, Stakeholders  
**Next Review Date:** End of Phase 1 (Week 6)  
**Contact:** Development Team Lead